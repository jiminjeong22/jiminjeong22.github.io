---
layout: post
title: "[혼공단 3기] 혼공C: Chapter 4. 연산자"
date:   2020-02-12T14:25:52-05:00
author: Jimin Jeong
categories: C
tags:	혼공단
---

## 4-1. 산술 연산자, 관계 연산자, 논리 연산자
- 피연산자: 연산 명령에 연산의 대상이 되는 데이터

### 산술 연산자와 대입 연산자
#### 산술 연산자
- 더하기: `+`
- 빼기: `-`
- 곱하기: `*` 
- 나누기: `/`
	- 나누기 연산자를 사용할 때는 피연산자의 형태에 따라 결과가 달라짐
		- 정수로 연산할 때는 몫을 구하고, 실수로 연산할 때는 소수점까지 구한다
- 나머지: `%`
- 대입 연산자: `=`

#### 나누기 연산자와 나머지 연산자
```
apple = 5.0 / 2.0;	// 출력결과: 2.5
banana = 5 / 2;		// 출력결과: 2
orange = 5 % 2;		// 출력결과: 1
```

### 증감 연산자
```
int a=10, b=10;

++a;	//출력결과: 11
--b;	//출력결과: 9
```

#### 전위표기와 후위 표기
- 전위표기 prefix : 값이 증감하고 나서 연산에 사용한다, 증감 연사자가 피연사자 앞에 놓임 `++a`
- 후위표기 postfix : 연산에 사용하고 나서 값이 증감, 증감 연사자가 피연산자 뒤에 놓임 `a++`
```
#include <stdio.h> 
int main(void) 
{
	int a=5, b=5;
	int pre, post; 
	
	pre = (++a) * 3;
	post = (b++) * 3;

	printf("초깃값 a = %d, b = %d\n", a, b);		//출력결과: a=6, b=6
	printf("전위형: (++a)*3 = %d, 후위형: (++a)*3 = %d\n", pre, post);		//출력결과: (++a)*3 = 18, (b++)*3 =15

	return 0;		
}	
```

### 관계 연산자
- 대소 관계 연산자 : `>`, `<`
- 동등 관계 연산자: `==`, `!=`
- 참 : `1`
- 거짓: `0`

### 논리 연산자
- and : `&&`
- or:  `||`
- not:  `!`

```
int a = 30;
int res;
res = (10 < a < 20) //결과: 1 (10<a는 1(참)이며, 1<20은 1(참))
res = (10 < a) && (a < 20) //결과: 0 (1&&0)
```
- 위 두 경우는 전혀 다른 결과를 도출하므로 수식을 만들 때 늘 유의해야 한다

#### 숏 서킷 룰 short circuit rule
- `&&`와 `||` 연산자는 숏 서킷 룰이 적용된다
- 숏 서킷 룰: 좌항만으로 `&&`와 `||` 연산 결과를 판별하는 기능
	- `&&` 연산자는 좌항이 거짓이면 우항과 관계없이 결과는 거짓이므로 우항을 살펴볼 필요가 없다
	- `||` 연산자는 좌항이 참이면 우항과 관계없이 결과가 참이다
	- 예시) (a<0)&&(++b>20) 에서 a<0이 거짓이면 ++b는 실행되지 않는다


#### 연산식이 컴퓨터 내부에서 처리되는 과정
sum = a + b;
1. 로드 load : 메모리에 있는 변수 값 (a,b)을 CPU의 저장공간인 레지스터에 복사됨
2. 데이터가 레지스터에 저장되면 연산장치인 ALU에 의해 덧셈 연산이 수행되고 그 결과 값은 일단 레지스터에 저장됨
3. 스토어 store : 메모리 공간인 sum에 복사되어 수식의 모든 과정이 완료됨

### CPU의 메모리와 RAM의 차이
- CPU의 메모리는 레지스터라고 하며, 연산할 데이터와 연산 후의 결과를 임시 저장한다. 보통 레지스터는 CPU의 클럭과 1:1 동기화되어 있어 메모리 RAM에 비해 엄청나게 빠르다. 실행속도만 생각한다면 메모리보다 레지스터를 사용하는 편이 훨씬 유리하다. 다만, 레지스터는 다음 연산을 위해 계속 사용되므로 연산 결과를 메모리로 옮겨놓지 않으면 그 값은 사라진다

## 4-2. 그 외 유용한 연산자
### 형 변환 연산자
`(자료형)피연산자`
- 형 변환 연산자는 피연산자가 1개이며 피연산자의 값을 원하는 형태로 바꾼다
- 형 변환 연산자를 사용해서 피연산자의 형태를 바꿀 때는 피연산자의 값을 복사하여 일시적으로 형태를 바꾸므로 연산 후 메모리에 있는 피연산자의 형태나 값은 변하지 않는다
- 자동 형 변환 : 피연산자의 형태가 서로 다르면 형태를 일치시키는 작업
	- 크기가 작은 값이 크기가 큰 값으로 바뀐다

### sizeof 연산자
- 피연산자의 크기를 바이트 단위로 계산해서 알려줌
- 피연산자의 대상은 변수, 상수, 수식, 자료형 등이 될 수 있다
- 데이터의 크기를 확인하거나 메모리를 동적으로 할당하는 작업 등에 유용하게 사용된다
- sizeof("A")의 값이 2인 이유는 문자열 끝에 \0 (null)이 삽입되기 때문이다

### 복합대입 연산자
- 복합대입 연산자는 연산 결과를 다시 피연산자에 저장한다
- `+=`, `-=`, `*=`, `/=`, `%=`
1. 왼쪽 피연산자는 반드시 변수가 와야 한다
2. 오른쪽 항의 계산이 모두 끝난 다음에 복합대입 연산자는 가장 마지막에 계산한다

### 콤마 연산자 (,)
- 콤마 연산자는 한 번에 여러 개의 수식을 차례로 나열해야 할 때 사용한다
- 왼쪽부터 오른쪽으로 차례로 연산을 수행하며 가장 오른쪽의 피연산자가 최종 결과값이 된다
- 콤마 연산자는 대입 연산자보다 우선순위가 낮은 유일한 연산자이다. 따라서, 대입 연산자와 함께 사용할 때는 반드시 괄호가 필요하다
	- `res = (++a, ++b);`  에서 res엔 ++b값이 저장된다
	- `res = ++a, ++b;`  에서 res엔 ++a값이 저장된다

### 조건 연산자
- `(a > b)? a: b`
- `(a> b)? (res1 = a) : (res2 = b) `
- 조건 연산자는 유일한 삼항 연산자로 `?`와  `:` 기호를 함께 사용한다
- 조건 연산자는 첫 번째 피연산자가 참이면 두 번째 피연산자가 결괏값이 되고, 첫 번째 피연산자가 거짓이면 세 번째 피연산자가 결괏값이 된다

### 비트 연산자
- 비트 연산자는 데이터를 비트 단위로 연산한다
- 비트 논리 연산자 
	- 논리곱 연산자 :  `&`
		- 두 비트가 모두 1인 경우에만 1로 계산한다
	- 배타적 논리합 연산자 : `^`
		- 두 비트가 서로 다른 경우에만 1로 계산한다
	- 논리합 연산자 : `|`
		- 두 비트 중 하나라도 참이면 1로 계산한다
	- 부정 연산자 : `~`
		- 비트를 반전시킴, 1은 0으로 0은 1로 바꾼다
- 비트 이동 연산자
	- 왼쪽으로 이동:  `<<`
	- 오른쪽으로 이동:  `>>`
	- 데이터를 비트로 정확히 표현할 수 있는 정수에만 사용 가능하다

### 연산자 우선순위와 연산 방향
- 단항 연산자 > 이항 연산자 > 삼항 연산자
- 산술 연산자 > 비트 이동 연산자 > 관계 연산자 > 논리 연산자


## 4-3. 확인 문제 (2주차 기본 미션)
![image](/assets/img/hongong/4-1-1.jpeg)
![image](/assets/img/hongong/4-1-2.jpeg)
![image](/assets/img/hongong/4-1-3.jpeg)
![image](/assets/img/hongong/4-2-1.jpeg)
![image](/assets/img/hongong/4-2-2.jpeg)


## 4-4. 도전 실전 예제 (2주차 선택 미션)

```
#include <stdio.h>
#include <math.h>

int main(void)
{
    double weight, height, BMI;

    printf("몸무게(kg)와 키(cm) 입력 : ");
    scanf("%lf %lf", &weight, &height);

    BMI = weight / pow(height/100, 2);

    printf("%s\n",((BMI >= 20.0) && (BMI < 25.0)) ? "표준입니다." : "체중관리가 필요합니다.");

    return 0;
}
```





